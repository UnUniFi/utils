/* tslint:disable */
/* eslint-disable */
/**
 * EURX - Legacy REST and gRPC Gateway docs
 * A REST interface for state queries, legacy transactions
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BotanyAuctionParams
 */
export interface BotanyAuctionParams {
    /**
     * 
     * @type {string}
     * @memberof BotanyAuctionParams
     */
    max_auction_duration?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyAuctionParams
     */
    bid_duration?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyAuctionParams
     */
    increment_surplus?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyAuctionParams
     */
    increment_debt?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyAuctionParams
     */
    increment_collateral?: string;
}
/**
 * 
 * @export
 * @interface BotanyAuctionQueryAllAuctionResponse
 */
export interface BotanyAuctionQueryAllAuctionResponse {
    /**
     * 
     * @type {Array<InlineResponse200Auctions>}
     * @memberof BotanyAuctionQueryAllAuctionResponse
     */
    auctions?: Array<InlineResponse200Auctions>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof BotanyAuctionQueryAllAuctionResponse
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface BotanyAuctionQueryGetAuctionResponse
 */
export interface BotanyAuctionQueryGetAuctionResponse {
    /**
     * 
     * @type {InlineResponse200Auctions}
     * @memberof BotanyAuctionQueryGetAuctionResponse
     */
    auction?: InlineResponse200Auctions;
}
/**
 * 
 * @export
 * @interface BotanyAuctionQueryParamsResponse
 */
export interface BotanyAuctionQueryParamsResponse {
    /**
     * 
     * @type {InlineResponse2002Params}
     * @memberof BotanyAuctionQueryParamsResponse
     */
    params?: InlineResponse2002Params;
}
/**
 * 
 * @export
 * @interface BotanyCdpAugmentedCdp
 */
export interface BotanyCdpAugmentedCdp {
    /**
     * 
     * @type {InlineResponse2004Cdp}
     * @memberof BotanyCdpAugmentedCdp
     */
    cdp?: InlineResponse2004Cdp;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof BotanyCdpAugmentedCdp
     */
    collateral_value?: InlineResponse2004CdpCollateral;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpAugmentedCdp
     */
    collateralization_ratio?: string;
}
/**
 * 
 * @export
 * @interface BotanyCdpCdp
 */
export interface BotanyCdpCdp {
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCdp
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCdp
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCdp
     */
    type?: string;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof BotanyCdpCdp
     */
    collateral?: InlineResponse2004CdpCollateral;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof BotanyCdpCdp
     */
    principal?: InlineResponse2004CdpCollateral;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof BotanyCdpCdp
     */
    accumulated_fees?: InlineResponse2004CdpCollateral;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCdp
     */
    fees_updated?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCdp
     */
    interest_factor?: string;
}
/**
 * 
 * @export
 * @interface BotanyCdpCollateralParam
 */
export interface BotanyCdpCollateralParam {
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCollateralParam
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCollateralParam
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCollateralParam
     */
    liquidation_ratio?: string;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof BotanyCdpCollateralParam
     */
    debt_limit?: InlineResponse2004CdpCollateral;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCollateralParam
     */
    stability_fee?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCollateralParam
     */
    auction_size?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCollateralParam
     */
    liquidation_penalty?: string;
    /**
     * 
     * @type {number}
     * @memberof BotanyCdpCollateralParam
     */
    prefix?: number;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCollateralParam
     */
    spot_market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCollateralParam
     */
    liquidation_market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCollateralParam
     */
    keeper_reward_percentage?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCollateralParam
     */
    check_collateralization_index_count?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpCollateralParam
     */
    conversion_factor?: string;
}
/**
 * 
 * @export
 * @interface BotanyCdpDebtParam
 */
export interface BotanyCdpDebtParam {
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpDebtParam
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpDebtParam
     */
    reference_asset?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpDebtParam
     */
    conversion_factor?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpDebtParam
     */
    debt_floor?: string;
}
/**
 * 
 * @export
 * @interface BotanyCdpDeposit
 */
export interface BotanyCdpDeposit {
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpDeposit
     */
    cdp_id?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpDeposit
     */
    depositor?: string;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof BotanyCdpDeposit
     */
    amount?: InlineResponse2004CdpCollateral;
}
/**
 * 
 * @export
 * @interface BotanyCdpParams
 */
export interface BotanyCdpParams {
    /**
     * 
     * @type {Array<InlineResponse2007ParamsCollateralParams>}
     * @memberof BotanyCdpParams
     */
    collateral_params?: Array<InlineResponse2007ParamsCollateralParams>;
    /**
     * 
     * @type {InlineResponse2007ParamsDebtParam}
     * @memberof BotanyCdpParams
     */
    debt_param?: InlineResponse2007ParamsDebtParam;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof BotanyCdpParams
     */
    global_debt_limit?: InlineResponse2004CdpCollateral;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpParams
     */
    surplus_auction_threshold?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpParams
     */
    surplus_auction_lot?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpParams
     */
    debt_auction_threshold?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyCdpParams
     */
    debt_auction_lot?: string;
    /**
     * 
     * @type {boolean}
     * @memberof BotanyCdpParams
     */
    circuit_breaker?: boolean;
}
/**
 * 
 * @export
 * @interface BotanyCdpQueryAllAccountResponse
 */
export interface BotanyCdpQueryAllAccountResponse {
    /**
     * 
     * @type {Array<InlineResponse200Auctions>}
     * @memberof BotanyCdpQueryAllAccountResponse
     */
    accounts?: Array<InlineResponse200Auctions>;
}
/**
 * 
 * @export
 * @interface BotanyCdpQueryAllCdpResponse
 */
export interface BotanyCdpQueryAllCdpResponse {
    /**
     * 
     * @type {Array<InlineResponse2004Cdp1>}
     * @memberof BotanyCdpQueryAllCdpResponse
     */
    cdp?: Array<InlineResponse2004Cdp1>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof BotanyCdpQueryAllCdpResponse
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface BotanyCdpQueryAllDepositResponse
 */
export interface BotanyCdpQueryAllDepositResponse {
    /**
     * 
     * @type {Array<InlineResponse2006Deposits>}
     * @memberof BotanyCdpQueryAllDepositResponse
     */
    deposits?: Array<InlineResponse2006Deposits>;
}
/**
 * 
 * @export
 * @interface BotanyCdpQueryGetCdpResponse
 */
export interface BotanyCdpQueryGetCdpResponse {
    /**
     * 
     * @type {InlineResponse2004Cdp1}
     * @memberof BotanyCdpQueryGetCdpResponse
     */
    cdp?: InlineResponse2004Cdp1;
}
/**
 * 
 * @export
 * @interface BotanyCdpQueryParamsResponse
 */
export interface BotanyCdpQueryParamsResponse {
    /**
     * 
     * @type {InlineResponse2007Params}
     * @memberof BotanyCdpQueryParamsResponse
     */
    params?: InlineResponse2007Params;
}
/**
 * 
 * @export
 * @interface BotanyPricefeedCurrentPrice
 */
export interface BotanyPricefeedCurrentPrice {
    /**
     * 
     * @type {string}
     * @memberof BotanyPricefeedCurrentPrice
     */
    market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyPricefeedCurrentPrice
     */
    price?: string;
}
/**
 * 
 * @export
 * @interface BotanyPricefeedMarket
 */
export interface BotanyPricefeedMarket {
    /**
     * 
     * @type {string}
     * @memberof BotanyPricefeedMarket
     */
    market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyPricefeedMarket
     */
    base_asset?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyPricefeedMarket
     */
    quote_asset?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof BotanyPricefeedMarket
     */
    oracles?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof BotanyPricefeedMarket
     */
    active?: boolean;
}
/**
 * 
 * @export
 * @interface BotanyPricefeedParams
 */
export interface BotanyPricefeedParams {
    /**
     * 
     * @type {Array<InlineResponse20011Markets>}
     * @memberof BotanyPricefeedParams
     */
    markets?: Array<InlineResponse20011Markets>;
}
/**
 * 
 * @export
 * @interface BotanyPricefeedPostedPrice
 */
export interface BotanyPricefeedPostedPrice {
    /**
     * 
     * @type {string}
     * @memberof BotanyPricefeedPostedPrice
     */
    market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyPricefeedPostedPrice
     */
    oracle_address?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyPricefeedPostedPrice
     */
    price?: string;
    /**
     * 
     * @type {string}
     * @memberof BotanyPricefeedPostedPrice
     */
    expiry?: string;
}
/**
 * 
 * @export
 * @interface BotanyPricefeedQueryAllMarketResponse
 */
export interface BotanyPricefeedQueryAllMarketResponse {
    /**
     * 
     * @type {Array<InlineResponse20011Markets>}
     * @memberof BotanyPricefeedQueryAllMarketResponse
     */
    markets?: Array<InlineResponse20011Markets>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof BotanyPricefeedQueryAllMarketResponse
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface BotanyPricefeedQueryAllOracleResponse
 */
export interface BotanyPricefeedQueryAllOracleResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof BotanyPricefeedQueryAllOracleResponse
     */
    oracles?: Array<string>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof BotanyPricefeedQueryAllOracleResponse
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface BotanyPricefeedQueryAllPriceResponse
 */
export interface BotanyPricefeedQueryAllPriceResponse {
    /**
     * 
     * @type {Array<InlineResponse20013Price>}
     * @memberof BotanyPricefeedQueryAllPriceResponse
     */
    prices?: Array<InlineResponse20013Price>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof BotanyPricefeedQueryAllPriceResponse
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface BotanyPricefeedQueryAllRawPriceResponse
 */
export interface BotanyPricefeedQueryAllRawPriceResponse {
    /**
     * 
     * @type {Array<InlineResponse20014Prices>}
     * @memberof BotanyPricefeedQueryAllRawPriceResponse
     */
    prices?: Array<InlineResponse20014Prices>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof BotanyPricefeedQueryAllRawPriceResponse
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface BotanyPricefeedQueryGetPriceResponse
 */
export interface BotanyPricefeedQueryGetPriceResponse {
    /**
     * 
     * @type {InlineResponse20013Price}
     * @memberof BotanyPricefeedQueryGetPriceResponse
     */
    price?: InlineResponse20013Price;
}
/**
 * 
 * @export
 * @interface BotanyPricefeedQueryParamsResponse
 */
export interface BotanyPricefeedQueryParamsResponse {
    /**
     * 
     * @type {InlineResponse20015Params}
     * @memberof BotanyPricefeedQueryParamsResponse
     */
    params?: InlineResponse20015Params;
}
/**
 * message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageRequest
 */
export interface CosmosBaseQueryV1beta1PageRequest {
    /**
     * key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    key?: string;
    /**
     * offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    offset?: string;
    /**
     * limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    limit?: string;
    /**
     * count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @type {boolean}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    count_total?: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageResponse
 */
export interface CosmosBaseQueryV1beta1PageResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageResponse
     */
    next_key?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageResponse
     */
    total?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface CosmosBaseV1beta1Coin
 */
export interface CosmosBaseV1beta1Coin {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1Coin
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1Coin
     */
    amount?: string;
}
/**
 * 
 * @export
 * @interface EurxEstmdistParams
 */
export interface EurxEstmdistParams {
    /**
     * 
     * @type {boolean}
     * @memberof EurxEstmdistParams
     */
    active?: boolean;
    /**
     * 
     * @type {Array<InlineResponse20010ParamsPeriods>}
     * @memberof EurxEstmdistParams
     */
    periods?: Array<InlineResponse20010ParamsPeriods>;
}
/**
 * 
 * @export
 * @interface EurxEstmdistPeriod
 */
export interface EurxEstmdistPeriod {
    /**
     * 
     * @type {string}
     * @memberof EurxEstmdistPeriod
     */
    start?: string;
    /**
     * 
     * @type {string}
     * @memberof EurxEstmdistPeriod
     */
    end?: string;
    /**
     * 
     * @type {string}
     * @memberof EurxEstmdistPeriod
     */
    inflation?: string;
}
/**
 * 
 * @export
 * @interface EurxEstmdistQueryGetBalancesResponse
 */
export interface EurxEstmdistQueryGetBalancesResponse {
    /**
     * 
     * @type {Array<InlineResponse2004CdpCollateral>}
     * @memberof EurxEstmdistQueryGetBalancesResponse
     */
    balances?: Array<InlineResponse2004CdpCollateral>;
}
/**
 * 
 * @export
 * @interface EurxEstmdistQueryParamsResponse
 */
export interface EurxEstmdistQueryParamsResponse {
    /**
     * 
     * @type {InlineResponse20010Params}
     * @memberof EurxEstmdistQueryParamsResponse
     */
    params?: InlineResponse20010Params;
}
/**
 * 
 * @export
 * @interface EurxIncentiveMultiplier
 */
export interface EurxIncentiveMultiplier {
    /**
     * 
     * @type {string}
     * @memberof EurxIncentiveMultiplier
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof EurxIncentiveMultiplier
     */
    months_lockup?: string;
    /**
     * 
     * @type {string}
     * @memberof EurxIncentiveMultiplier
     */
    factor?: string;
}
/**
 * 
 * @export
 * @interface EurxIncentiveParams
 */
export interface EurxIncentiveParams {
    /**
     * 
     * @type {Array<InlineResponse2008ParamsEurxMintingRewardPeriods>}
     * @memberof EurxIncentiveParams
     */
    eurx_minting_reward_periods?: Array<InlineResponse2008ParamsEurxMintingRewardPeriods>;
    /**
     * 
     * @type {Array<InlineResponse2008ParamsClaimMultipliers>}
     * @memberof EurxIncentiveParams
     */
    claim_multipliers?: Array<InlineResponse2008ParamsClaimMultipliers>;
    /**
     * 
     * @type {string}
     * @memberof EurxIncentiveParams
     */
    claim_end?: string;
}
/**
 * 
 * @export
 * @interface EurxIncentiveQueryParamsResponse
 */
export interface EurxIncentiveQueryParamsResponse {
    /**
     * 
     * @type {InlineResponse2008Params}
     * @memberof EurxIncentiveQueryParamsResponse
     */
    params?: InlineResponse2008Params;
}
/**
 * 
 * @export
 * @interface EurxIncentiveRewardPeriod
 */
export interface EurxIncentiveRewardPeriod {
    /**
     * 
     * @type {boolean}
     * @memberof EurxIncentiveRewardPeriod
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof EurxIncentiveRewardPeriod
     */
    collateral_type?: string;
    /**
     * 
     * @type {string}
     * @memberof EurxIncentiveRewardPeriod
     */
    start?: string;
    /**
     * 
     * @type {string}
     * @memberof EurxIncentiveRewardPeriod
     */
    end?: string;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof EurxIncentiveRewardPeriod
     */
    rewards_per_second?: InlineResponse2004CdpCollateral;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface GoogleProtobufAny
 */
export interface GoogleProtobufAny {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface GrpcGatewayRuntimeError
 */
export interface GrpcGatewayRuntimeError {
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    message?: string;
    /**
     * 
     * @type {Array<InlineResponse200Auctions>}
     * @memberof GrpcGatewayRuntimeError
     */
    details?: Array<InlineResponse200Auctions>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<InlineResponse200Auctions>}
     * @memberof InlineResponse200
     */
    auctions?: Array<InlineResponse200Auctions>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof InlineResponse200
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {InlineResponse200Auctions}
     * @memberof InlineResponse2001
     */
    auction?: InlineResponse200Auctions;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {InlineResponse20010Params}
     * @memberof InlineResponse20010
     */
    params?: InlineResponse20010Params;
}
/**
 * 
 * @export
 * @interface InlineResponse20010Params
 */
export interface InlineResponse20010Params {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20010Params
     */
    active?: boolean;
    /**
     * 
     * @type {Array<InlineResponse20010ParamsPeriods>}
     * @memberof InlineResponse20010Params
     */
    periods?: Array<InlineResponse20010ParamsPeriods>;
}
/**
 * 
 * @export
 * @interface InlineResponse20010ParamsPeriods
 */
export interface InlineResponse20010ParamsPeriods {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010ParamsPeriods
     */
    start?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010ParamsPeriods
     */
    end?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20010ParamsPeriods
     */
    inflation?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {Array<InlineResponse20011Markets>}
     * @memberof InlineResponse20011
     */
    markets?: Array<InlineResponse20011Markets>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof InlineResponse20011
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse20011Markets
 */
export interface InlineResponse20011Markets {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Markets
     */
    market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Markets
     */
    base_asset?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Markets
     */
    quote_asset?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse20011Markets
     */
    oracles?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse20011Markets
     */
    active?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse20012
     */
    oracles?: Array<string>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof InlineResponse20012
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * 
     * @type {InlineResponse20013Price}
     * @memberof InlineResponse20013
     */
    price?: InlineResponse20013Price;
}
/**
 * 
 * @export
 * @interface InlineResponse20013Price
 */
export interface InlineResponse20013Price {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013Price
     */
    market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20013Price
     */
    price?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * 
     * @type {Array<InlineResponse20014Prices>}
     * @memberof InlineResponse20014
     */
    prices?: Array<InlineResponse20014Prices>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof InlineResponse20014
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse20014Prices
 */
export interface InlineResponse20014Prices {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014Prices
     */
    market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014Prices
     */
    oracle_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014Prices
     */
    price?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20014Prices
     */
    expiry?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20015
 */
export interface InlineResponse20015 {
    /**
     * 
     * @type {InlineResponse20015Params}
     * @memberof InlineResponse20015
     */
    params?: InlineResponse20015Params;
}
/**
 * 
 * @export
 * @interface InlineResponse20015Params
 */
export interface InlineResponse20015Params {
    /**
     * 
     * @type {Array<InlineResponse20011Markets>}
     * @memberof InlineResponse20015Params
     */
    markets?: Array<InlineResponse20011Markets>;
}
/**
 * 
 * @export
 * @interface InlineResponse20016
 */
export interface InlineResponse20016 {
    /**
     * 
     * @type {Array<InlineResponse20013Price>}
     * @memberof InlineResponse20016
     */
    prices?: Array<InlineResponse20013Price>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof InlineResponse20016
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {InlineResponse2002Params}
     * @memberof InlineResponse2002
     */
    params?: InlineResponse2002Params;
}
/**
 * 
 * @export
 * @interface InlineResponse2002Params
 */
export interface InlineResponse2002Params {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Params
     */
    max_auction_duration?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Params
     */
    bid_duration?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Params
     */
    increment_surplus?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Params
     */
    increment_debt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Params
     */
    increment_collateral?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {Array<InlineResponse200Auctions>}
     * @memberof InlineResponse2003
     */
    accounts?: Array<InlineResponse200Auctions>;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {Array<InlineResponse2004Cdp1>}
     * @memberof InlineResponse2004
     */
    cdp?: Array<InlineResponse2004Cdp1>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof InlineResponse2004
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2004Cdp
 */
export interface InlineResponse2004Cdp {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Cdp
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Cdp
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Cdp
     */
    type?: string;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof InlineResponse2004Cdp
     */
    collateral?: InlineResponse2004CdpCollateral;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof InlineResponse2004Cdp
     */
    principal?: InlineResponse2004CdpCollateral;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof InlineResponse2004Cdp
     */
    accumulated_fees?: InlineResponse2004CdpCollateral;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Cdp
     */
    fees_updated?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Cdp
     */
    interest_factor?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004Cdp1
 */
export interface InlineResponse2004Cdp1 {
    /**
     * 
     * @type {InlineResponse2004Cdp}
     * @memberof InlineResponse2004Cdp1
     */
    cdp?: InlineResponse2004Cdp;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof InlineResponse2004Cdp1
     */
    collateral_value?: InlineResponse2004CdpCollateral;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004Cdp1
     */
    collateralization_ratio?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface InlineResponse2004CdpCollateral
 */
export interface InlineResponse2004CdpCollateral {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004CdpCollateral
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2004CdpCollateral
     */
    amount?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {InlineResponse2004Cdp1}
     * @memberof InlineResponse2005
     */
    cdp?: InlineResponse2004Cdp1;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {Array<InlineResponse2006Deposits>}
     * @memberof InlineResponse2006
     */
    deposits?: Array<InlineResponse2006Deposits>;
}
/**
 * 
 * @export
 * @interface InlineResponse2006Deposits
 */
export interface InlineResponse2006Deposits {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Deposits
     */
    cdp_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Deposits
     */
    depositor?: string;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof InlineResponse2006Deposits
     */
    amount?: InlineResponse2004CdpCollateral;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {InlineResponse2007Params}
     * @memberof InlineResponse2007
     */
    params?: InlineResponse2007Params;
}
/**
 * 
 * @export
 * @interface InlineResponse2007Params
 */
export interface InlineResponse2007Params {
    /**
     * 
     * @type {Array<InlineResponse2007ParamsCollateralParams>}
     * @memberof InlineResponse2007Params
     */
    collateral_params?: Array<InlineResponse2007ParamsCollateralParams>;
    /**
     * 
     * @type {InlineResponse2007ParamsDebtParam}
     * @memberof InlineResponse2007Params
     */
    debt_param?: InlineResponse2007ParamsDebtParam;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof InlineResponse2007Params
     */
    global_debt_limit?: InlineResponse2004CdpCollateral;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007Params
     */
    surplus_auction_threshold?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007Params
     */
    surplus_auction_lot?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007Params
     */
    debt_auction_threshold?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007Params
     */
    debt_auction_lot?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2007Params
     */
    circuit_breaker?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2007ParamsCollateralParams
 */
export interface InlineResponse2007ParamsCollateralParams {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007ParamsCollateralParams
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007ParamsCollateralParams
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007ParamsCollateralParams
     */
    liquidation_ratio?: string;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof InlineResponse2007ParamsCollateralParams
     */
    debt_limit?: InlineResponse2004CdpCollateral;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007ParamsCollateralParams
     */
    stability_fee?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007ParamsCollateralParams
     */
    auction_size?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007ParamsCollateralParams
     */
    liquidation_penalty?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2007ParamsCollateralParams
     */
    prefix?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007ParamsCollateralParams
     */
    spot_market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007ParamsCollateralParams
     */
    liquidation_market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007ParamsCollateralParams
     */
    keeper_reward_percentage?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007ParamsCollateralParams
     */
    check_collateralization_index_count?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007ParamsCollateralParams
     */
    conversion_factor?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2007ParamsDebtParam
 */
export interface InlineResponse2007ParamsDebtParam {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007ParamsDebtParam
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007ParamsDebtParam
     */
    reference_asset?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007ParamsDebtParam
     */
    conversion_factor?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2007ParamsDebtParam
     */
    debt_floor?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {InlineResponse2008Params}
     * @memberof InlineResponse2008
     */
    params?: InlineResponse2008Params;
}
/**
 * 
 * @export
 * @interface InlineResponse2008Params
 */
export interface InlineResponse2008Params {
    /**
     * 
     * @type {Array<InlineResponse2008ParamsEurxMintingRewardPeriods>}
     * @memberof InlineResponse2008Params
     */
    eurx_minting_reward_periods?: Array<InlineResponse2008ParamsEurxMintingRewardPeriods>;
    /**
     * 
     * @type {Array<InlineResponse2008ParamsClaimMultipliers>}
     * @memberof InlineResponse2008Params
     */
    claim_multipliers?: Array<InlineResponse2008ParamsClaimMultipliers>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008Params
     */
    claim_end?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2008ParamsClaimMultipliers
 */
export interface InlineResponse2008ParamsClaimMultipliers {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008ParamsClaimMultipliers
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008ParamsClaimMultipliers
     */
    months_lockup?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008ParamsClaimMultipliers
     */
    factor?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2008ParamsEurxMintingRewardPeriods
 */
export interface InlineResponse2008ParamsEurxMintingRewardPeriods {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2008ParamsEurxMintingRewardPeriods
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008ParamsEurxMintingRewardPeriods
     */
    collateral_type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008ParamsEurxMintingRewardPeriods
     */
    start?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008ParamsEurxMintingRewardPeriods
     */
    end?: string;
    /**
     * 
     * @type {InlineResponse2004CdpCollateral}
     * @memberof InlineResponse2008ParamsEurxMintingRewardPeriods
     */
    rewards_per_second?: InlineResponse2004CdpCollateral;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {Array<InlineResponse2004CdpCollateral>}
     * @memberof InlineResponse2009
     */
    balances?: Array<InlineResponse2004CdpCollateral>;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface InlineResponse200Auctions
 */
export interface InlineResponse200Auctions {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof InlineResponse200Auctions
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof InlineResponse200Auctions
     */
    value?: string;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface InlineResponse200Pagination
 */
export interface InlineResponse200Pagination {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Pagination
     */
    next_key?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Pagination
     */
    total?: string;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault
 */
export interface InlineResponseDefault {
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault
     */
    message?: string;
    /**
     * 
     * @type {Array<InlineResponse200Auctions>}
     * @memberof InlineResponseDefault
     */
    details?: Array<InlineResponse200Auctions>;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault1
 */
export interface InlineResponseDefault1 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault1
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault1
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault1
     */
    message?: string;
    /**
     * 
     * @type {Array<InlineResponseDefault1Details>}
     * @memberof InlineResponseDefault1
     */
    details?: Array<InlineResponseDefault1Details>;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault1Details
 */
export interface InlineResponseDefault1Details {
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault1Details
     */
    type_url?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault1Details
     */
    value?: string;
}

/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAll: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/botany/cdp/accounts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auction: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling auction.');
            }
            const localVarPath = `/botany/auction/auctions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auctionAll: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/botany/auction/auctions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auctionParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/botany/auction/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balances: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/eurx/estmdist/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} owner 
         * @param {string} collateralType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cdp: async (owner: string, collateralType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling cdp.');
            }
            // verify required parameter 'collateralType' is not null or undefined
            if (collateralType === null || collateralType === undefined) {
                throw new RequiredError('collateralType','Required parameter collateralType was null or undefined when calling cdp.');
            }
            const localVarPath = `/botany/cdp/cdps/owners/{owner}/collateral-types/{collateral_type}/cdp`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"collateral_type"}}`, encodeURIComponent(String(collateralType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cdpAll: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/botany/cdp/cdps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cdpParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/botany/cdp/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} owner 
         * @param {string} collateralType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositAll: async (owner: string, collateralType: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'owner' is not null or undefined
            if (owner === null || owner === undefined) {
                throw new RequiredError('owner','Required parameter owner was null or undefined when calling depositAll.');
            }
            // verify required parameter 'collateralType' is not null or undefined
            if (collateralType === null || collateralType === undefined) {
                throw new RequiredError('collateralType','Required parameter collateralType was null or undefined when calling depositAll.');
            }
            const localVarPath = `/botany/cdp/deposits/owners/{owner}/collateral-types/{collateral_type}`
                .replace(`{${"owner"}}`, encodeURIComponent(String(owner)))
                .replace(`{${"collateral_type"}}`, encodeURIComponent(String(collateralType)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estmdistParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/eurx/estmdist/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incentiveParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/eurx/incentive/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketAll: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/botany/pricefeed/markets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oracleAll: async (marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketId' is not null or undefined
            if (marketId === null || marketId === undefined) {
                throw new RequiredError('marketId','Required parameter marketId was null or undefined when calling oracleAll.');
            }
            const localVarPath = `/botany/pricefeed/markets/{market_id}/oracles`
                .replace(`{${"market_id"}}`, encodeURIComponent(String(marketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        price: async (marketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketId' is not null or undefined
            if (marketId === null || marketId === undefined) {
                throw new RequiredError('marketId','Required parameter marketId was null or undefined when calling price.');
            }
            const localVarPath = `/botany/pricefeed/markets/{market_id}/price`
                .replace(`{${"market_id"}}`, encodeURIComponent(String(marketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceAll: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/botany/pricefeed/prices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricefeedParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/botany/pricefeed/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawPriceAll: async (marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketId' is not null or undefined
            if (marketId === null || marketId === undefined) {
                throw new RequiredError('marketId','Required parameter marketId was null or undefined when calling rawPriceAll.');
            }
            const localVarPath = `/botany/pricefeed/markets/{market_id}/raw_prices`
                .replace(`{${"market_id"}}`, encodeURIComponent(String(marketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accountAll(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).accountAll(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auction(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).auction(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auctionAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).auctionAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auctionParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).auctionParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balances(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).balances(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} owner 
         * @param {string} collateralType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cdp(owner: string, collateralType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).cdp(owner, collateralType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cdpAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).cdpAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cdpParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).cdpParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} owner 
         * @param {string} collateralType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async depositAll(owner: string, collateralType: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).depositAll(owner, collateralType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async estmdistParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).estmdistParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async incentiveParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).incentiveParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).marketAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oracleAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).oracleAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} marketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async price(marketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).price(marketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20016>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).priceAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricefeedParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20015>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).pricefeedParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rawPriceAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).rawPriceAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountAll(options?: any): AxiosPromise<InlineResponse2003> {
            return QueryApiFp(configuration).accountAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auction(id: string, options?: any): AxiosPromise<InlineResponse2001> {
            return QueryApiFp(configuration).auction(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auctionAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse200> {
            return QueryApiFp(configuration).auctionAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auctionParams(options?: any): AxiosPromise<InlineResponse2002> {
            return QueryApiFp(configuration).auctionParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balances(options?: any): AxiosPromise<InlineResponse2009> {
            return QueryApiFp(configuration).balances(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} owner 
         * @param {string} collateralType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cdp(owner: string, collateralType: string, options?: any): AxiosPromise<InlineResponse2005> {
            return QueryApiFp(configuration).cdp(owner, collateralType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cdpAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse2004> {
            return QueryApiFp(configuration).cdpAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cdpParams(options?: any): AxiosPromise<InlineResponse2007> {
            return QueryApiFp(configuration).cdpParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} owner 
         * @param {string} collateralType 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        depositAll(owner: string, collateralType: string, options?: any): AxiosPromise<InlineResponse2006> {
            return QueryApiFp(configuration).depositAll(owner, collateralType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        estmdistParams(options?: any): AxiosPromise<InlineResponse20010> {
            return QueryApiFp(configuration).estmdistParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incentiveParams(options?: any): AxiosPromise<InlineResponse2008> {
            return QueryApiFp(configuration).incentiveParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20011> {
            return QueryApiFp(configuration).marketAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oracleAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20012> {
            return QueryApiFp(configuration).oracleAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        price(marketId: string, options?: any): AxiosPromise<InlineResponse20013> {
            return QueryApiFp(configuration).price(marketId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20016> {
            return QueryApiFp(configuration).priceAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricefeedParams(options?: any): AxiosPromise<InlineResponse20015> {
            return QueryApiFp(configuration).pricefeedParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawPriceAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20014> {
            return QueryApiFp(configuration).rawPriceAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public accountAll(options?: any) {
        return QueryApiFp(this.configuration).accountAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary this line is used by starport scaffolding # 2
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public auction(id: string, options?: any) {
        return QueryApiFp(this.configuration).auction(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public auctionAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).auctionAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public auctionParams(options?: any) {
        return QueryApiFp(this.configuration).auctionParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary this line is used by starport scaffolding # 2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public balances(options?: any) {
        return QueryApiFp(this.configuration).balances(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary this line is used by starport scaffolding # 2
     * @param {string} owner 
     * @param {string} collateralType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public cdp(owner: string, collateralType: string, options?: any) {
        return QueryApiFp(this.configuration).cdp(owner, collateralType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public cdpAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).cdpAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public cdpParams(options?: any) {
        return QueryApiFp(this.configuration).cdpParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} owner 
     * @param {string} collateralType 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public depositAll(owner: string, collateralType: string, options?: any) {
        return QueryApiFp(this.configuration).depositAll(owner, collateralType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public estmdistParams(options?: any) {
        return QueryApiFp(this.configuration).estmdistParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public incentiveParams(options?: any) {
        return QueryApiFp(this.configuration).incentiveParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary this line is used by starport scaffolding # 2
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public marketAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).marketAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketId 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public oracleAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).oracleAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public price(marketId: string, options?: any) {
        return QueryApiFp(this.configuration).price(marketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public priceAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).priceAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public pricefeedParams(options?: any) {
        return QueryApiFp(this.configuration).pricefeedParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketId 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public rawPriceAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).rawPriceAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }
}


