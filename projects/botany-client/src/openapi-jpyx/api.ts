/* tslint:disable */
/* eslint-disable */
/**
 * JPYX - Legacy REST and gRPC Gateway docs
 * A REST interface for state queries, legacy transactions
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * message SomeRequest {          Foo some_parameter = 1;          PageRequest pagination = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageRequest
 */
export interface CosmosBaseQueryV1beta1PageRequest {
    /**
     * key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    key?: string;
    /**
     * offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    offset?: string;
    /**
     * limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    limit?: string;
    /**
     * count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @type {boolean}
     * @memberof CosmosBaseQueryV1beta1PageRequest
     */
    count_total?: boolean;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface CosmosBaseQueryV1beta1PageResponse
 */
export interface CosmosBaseQueryV1beta1PageResponse {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageResponse
     */
    next_key?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseQueryV1beta1PageResponse
     */
    total?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface CosmosBaseV1beta1Coin
 */
export interface CosmosBaseV1beta1Coin {
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1Coin
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof CosmosBaseV1beta1Coin
     */
    amount?: string;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface GoogleProtobufAny
 */
export interface GoogleProtobufAny {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof GoogleProtobufAny
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface GrpcGatewayRuntimeError
 */
export interface GrpcGatewayRuntimeError {
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof GrpcGatewayRuntimeError
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof GrpcGatewayRuntimeError
     */
    message?: string;
    /**
     * 
     * @type {Array<InlineResponse200Auctions>}
     * @memberof GrpcGatewayRuntimeError
     */
    details?: Array<InlineResponse200Auctions>;
}
/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<InlineResponse200Auctions>}
     * @memberof InlineResponse200
     */
    auctions?: Array<InlineResponse200Auctions>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof InlineResponse200
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {InlineResponse200Auctions}
     * @memberof InlineResponse2001
     */
    auction?: InlineResponse200Auctions;
}
/**
 * 
 * @export
 * @interface InlineResponse20010
 */
export interface InlineResponse20010 {
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse20010
     */
    oracles?: Array<string>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof InlineResponse20010
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse20011
 */
export interface InlineResponse20011 {
    /**
     * 
     * @type {InlineResponse20011Price}
     * @memberof InlineResponse20011
     */
    price?: InlineResponse20011Price;
}
/**
 * 
 * @export
 * @interface InlineResponse20011Price
 */
export interface InlineResponse20011Price {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Price
     */
    market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20011Price
     */
    price?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20012
 */
export interface InlineResponse20012 {
    /**
     * 
     * @type {Array<InlineResponse20012Prices>}
     * @memberof InlineResponse20012
     */
    prices?: Array<InlineResponse20012Prices>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof InlineResponse20012
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse20012Prices
 */
export interface InlineResponse20012Prices {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012Prices
     */
    market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012Prices
     */
    oracle_address?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012Prices
     */
    price?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse20012Prices
     */
    expiry?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse20013
 */
export interface InlineResponse20013 {
    /**
     * 
     * @type {InlineResponse20013Params}
     * @memberof InlineResponse20013
     */
    params?: InlineResponse20013Params;
}
/**
 * 
 * @export
 * @interface InlineResponse20013Params
 */
export interface InlineResponse20013Params {
    /**
     * 
     * @type {Array<InlineResponse2009Markets>}
     * @memberof InlineResponse20013Params
     */
    markets?: Array<InlineResponse2009Markets>;
}
/**
 * 
 * @export
 * @interface InlineResponse20014
 */
export interface InlineResponse20014 {
    /**
     * 
     * @type {Array<InlineResponse20011Price>}
     * @memberof InlineResponse20014
     */
    prices?: Array<InlineResponse20011Price>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof InlineResponse20014
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {InlineResponse2002Params}
     * @memberof InlineResponse2002
     */
    params?: InlineResponse2002Params;
}
/**
 * 
 * @export
 * @interface InlineResponse2002Params
 */
export interface InlineResponse2002Params {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Params
     */
    max_auction_duration?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Params
     */
    bid_duration?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Params
     */
    increment_surplus?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Params
     */
    increment_debt?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2002Params
     */
    increment_collateral?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {Array<InlineResponse2003Cdp>}
     * @memberof InlineResponse2003
     */
    Cdp?: Array<InlineResponse2003Cdp>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof InlineResponse2003
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2003Cdp
 */
export interface InlineResponse2003Cdp {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Cdp
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Cdp
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Cdp
     */
    type?: string;
    /**
     * 
     * @type {InlineResponse2003Collateral}
     * @memberof InlineResponse2003Cdp
     */
    collateral?: InlineResponse2003Collateral;
    /**
     * 
     * @type {InlineResponse2003Collateral}
     * @memberof InlineResponse2003Cdp
     */
    principal?: InlineResponse2003Collateral;
    /**
     * 
     * @type {InlineResponse2003Collateral}
     * @memberof InlineResponse2003Cdp
     */
    accumulated_fees?: InlineResponse2003Collateral;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Cdp
     */
    fees_updated?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Cdp
     */
    interest_factor?: string;
}
/**
 * Coin defines a token with a denomination and an amount.  NOTE: The amount field is an Int which implements the custom method signatures required by gogoproto.
 * @export
 * @interface InlineResponse2003Collateral
 */
export interface InlineResponse2003Collateral {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Collateral
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2003Collateral
     */
    amount?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {InlineResponse2003Cdp}
     * @memberof InlineResponse2004
     */
    Cdp?: InlineResponse2003Cdp;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {InlineResponse2005Params}
     * @memberof InlineResponse2005
     */
    params?: InlineResponse2005Params;
}
/**
 * 
 * @export
 * @interface InlineResponse2005Params
 */
export interface InlineResponse2005Params {
    /**
     * 
     * @type {Array<InlineResponse2005ParamsCollateralParams>}
     * @memberof InlineResponse2005Params
     */
    collateral_params?: Array<InlineResponse2005ParamsCollateralParams>;
    /**
     * 
     * @type {InlineResponse2005ParamsDebtParam}
     * @memberof InlineResponse2005Params
     */
    debt_param?: InlineResponse2005ParamsDebtParam;
    /**
     * 
     * @type {InlineResponse2003Collateral}
     * @memberof InlineResponse2005Params
     */
    global_debt_limit?: InlineResponse2003Collateral;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Params
     */
    surplus_auction_threshold?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Params
     */
    surplus_auction_lot?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Params
     */
    debt_auction_threshold?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005Params
     */
    debt_auction_lot?: string;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2005Params
     */
    circuit_breaker?: boolean;
}
/**
 * 
 * @export
 * @interface InlineResponse2005ParamsCollateralParams
 */
export interface InlineResponse2005ParamsCollateralParams {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005ParamsCollateralParams
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005ParamsCollateralParams
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005ParamsCollateralParams
     */
    liquidation_ratio?: string;
    /**
     * 
     * @type {InlineResponse2003Collateral}
     * @memberof InlineResponse2005ParamsCollateralParams
     */
    debt_limit?: InlineResponse2003Collateral;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005ParamsCollateralParams
     */
    stability_fee?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005ParamsCollateralParams
     */
    auction_size?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005ParamsCollateralParams
     */
    liquidation_penalty?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponse2005ParamsCollateralParams
     */
    prefix?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005ParamsCollateralParams
     */
    spot_market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005ParamsCollateralParams
     */
    liquidation_market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005ParamsCollateralParams
     */
    keeper_reward_percentage?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005ParamsCollateralParams
     */
    check_collateralization_index_count?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005ParamsCollateralParams
     */
    conversion_factor?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2005ParamsDebtParam
 */
export interface InlineResponse2005ParamsDebtParam {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005ParamsDebtParam
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005ParamsDebtParam
     */
    reference_asset?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005ParamsDebtParam
     */
    conversion_factor?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2005ParamsDebtParam
     */
    debt_floor?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006
 */
export interface InlineResponse2006 {
    /**
     * 
     * @type {InlineResponse2006Params}
     * @memberof InlineResponse2006
     */
    params?: InlineResponse2006Params;
}
/**
 * 
 * @export
 * @interface InlineResponse2006Params
 */
export interface InlineResponse2006Params {
    /**
     * 
     * @type {Array<InlineResponse2006ParamsJpyxMintingRewardPeriods>}
     * @memberof InlineResponse2006Params
     */
    jpyx_minting_reward_periods?: Array<InlineResponse2006ParamsJpyxMintingRewardPeriods>;
    /**
     * 
     * @type {Array<InlineResponse2006ParamsClaimMultipliers>}
     * @memberof InlineResponse2006Params
     */
    claim_multipliers?: Array<InlineResponse2006ParamsClaimMultipliers>;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006Params
     */
    claim_end?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006ParamsClaimMultipliers
 */
export interface InlineResponse2006ParamsClaimMultipliers {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006ParamsClaimMultipliers
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006ParamsClaimMultipliers
     */
    months_lockup?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006ParamsClaimMultipliers
     */
    factor?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2006ParamsJpyxMintingRewardPeriods
 */
export interface InlineResponse2006ParamsJpyxMintingRewardPeriods {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2006ParamsJpyxMintingRewardPeriods
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006ParamsJpyxMintingRewardPeriods
     */
    collateral_type?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006ParamsJpyxMintingRewardPeriods
     */
    start?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2006ParamsJpyxMintingRewardPeriods
     */
    end?: string;
    /**
     * 
     * @type {InlineResponse2003Collateral}
     * @memberof InlineResponse2006ParamsJpyxMintingRewardPeriods
     */
    rewards_per_second?: InlineResponse2003Collateral;
}
/**
 * 
 * @export
 * @interface InlineResponse2007
 */
export interface InlineResponse2007 {
    /**
     * 
     * @type {Array<InlineResponse2003Collateral>}
     * @memberof InlineResponse2007
     */
    balances?: Array<InlineResponse2003Collateral>;
}
/**
 * 
 * @export
 * @interface InlineResponse2008
 */
export interface InlineResponse2008 {
    /**
     * 
     * @type {InlineResponse2008Params}
     * @memberof InlineResponse2008
     */
    params?: InlineResponse2008Params;
}
/**
 * 
 * @export
 * @interface InlineResponse2008Params
 */
export interface InlineResponse2008Params {
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2008Params
     */
    active?: boolean;
    /**
     * 
     * @type {Array<InlineResponse2008ParamsPeriods>}
     * @memberof InlineResponse2008Params
     */
    periods?: Array<InlineResponse2008ParamsPeriods>;
}
/**
 * 
 * @export
 * @interface InlineResponse2008ParamsPeriods
 */
export interface InlineResponse2008ParamsPeriods {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008ParamsPeriods
     */
    start?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008ParamsPeriods
     */
    end?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2008ParamsPeriods
     */
    inflation?: string;
}
/**
 * 
 * @export
 * @interface InlineResponse2009
 */
export interface InlineResponse2009 {
    /**
     * 
     * @type {Array<InlineResponse2009Markets>}
     * @memberof InlineResponse2009
     */
    markets?: Array<InlineResponse2009Markets>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof InlineResponse2009
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2009Markets
 */
export interface InlineResponse2009Markets {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009Markets
     */
    market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009Markets
     */
    base_asset?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse2009Markets
     */
    quote_asset?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineResponse2009Markets
     */
    oracles?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof InlineResponse2009Markets
     */
    active?: boolean;
}
/**
 * `Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.  Protobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.  Example 1: Pack and unpack a message in C++.      Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }  Example 2: Pack and unpack a message in Java.      Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }   Example 3: Pack and unpack a message in Python.      foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...   Example 4: Pack and unpack a message in Go       foo := &pb.Foo{...}      any, err := ptypes.MarshalAny(foo)      ...      foo := &pb.Foo{}      if err := ptypes.UnmarshalAny(any, foo); err != nil {        ...      }  The pack methods provided by protobuf library will by default use \'type.googleapis.com/full.type.name\' as the type URL and the unpack methods only use the fully qualified type name after the last \'/\' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".   JSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:      package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }      {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }  If the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):      {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }
 * @export
 * @interface InlineResponse200Auctions
 */
export interface InlineResponse200Auctions {
    /**
     * A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL\'s path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).  In practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:  * If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)  Note: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.  Schemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics.
     * @type {string}
     * @memberof InlineResponse200Auctions
     */
    type_url?: string;
    /**
     * Must be a valid serialized protocol buffer of the above specified type.
     * @type {string}
     * @memberof InlineResponse200Auctions
     */
    value?: string;
}
/**
 * PageResponse is to be embedded in gRPC response messages where the corresponding request message has used PageRequest.   message SomeResponse {          repeated Bar results = 1;          PageResponse page = 2;  }
 * @export
 * @interface InlineResponse200Pagination
 */
export interface InlineResponse200Pagination {
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Pagination
     */
    next_key?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponse200Pagination
     */
    total?: string;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault
 */
export interface InlineResponseDefault {
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault
     */
    message?: string;
    /**
     * 
     * @type {Array<InlineResponse200Auctions>}
     * @memberof InlineResponseDefault
     */
    details?: Array<InlineResponse200Auctions>;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault1
 */
export interface InlineResponseDefault1 {
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault1
     */
    error?: string;
    /**
     * 
     * @type {number}
     * @memberof InlineResponseDefault1
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault1
     */
    message?: string;
    /**
     * 
     * @type {Array<InlineResponseDefault1Details>}
     * @memberof InlineResponseDefault1
     */
    details?: Array<InlineResponseDefault1Details>;
}
/**
 * 
 * @export
 * @interface InlineResponseDefault1Details
 */
export interface InlineResponseDefault1Details {
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault1Details
     */
    type_url?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineResponseDefault1Details
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface JpyxAuctionParams
 */
export interface JpyxAuctionParams {
    /**
     * 
     * @type {string}
     * @memberof JpyxAuctionParams
     */
    max_auction_duration?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxAuctionParams
     */
    bid_duration?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxAuctionParams
     */
    increment_surplus?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxAuctionParams
     */
    increment_debt?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxAuctionParams
     */
    increment_collateral?: string;
}
/**
 * 
 * @export
 * @interface JpyxAuctionQueryAllAuctionResponse
 */
export interface JpyxAuctionQueryAllAuctionResponse {
    /**
     * 
     * @type {Array<InlineResponse200Auctions>}
     * @memberof JpyxAuctionQueryAllAuctionResponse
     */
    auctions?: Array<InlineResponse200Auctions>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof JpyxAuctionQueryAllAuctionResponse
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface JpyxAuctionQueryGetAuctionResponse
 */
export interface JpyxAuctionQueryGetAuctionResponse {
    /**
     * 
     * @type {InlineResponse200Auctions}
     * @memberof JpyxAuctionQueryGetAuctionResponse
     */
    auction?: InlineResponse200Auctions;
}
/**
 * 
 * @export
 * @interface JpyxAuctionQueryParamsResponse
 */
export interface JpyxAuctionQueryParamsResponse {
    /**
     * 
     * @type {InlineResponse2002Params}
     * @memberof JpyxAuctionQueryParamsResponse
     */
    params?: InlineResponse2002Params;
}
/**
 * 
 * @export
 * @interface JpyxCdpCDP
 */
export interface JpyxCdpCDP {
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCDP
     */
    id?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCDP
     */
    owner?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCDP
     */
    type?: string;
    /**
     * 
     * @type {InlineResponse2003Collateral}
     * @memberof JpyxCdpCDP
     */
    collateral?: InlineResponse2003Collateral;
    /**
     * 
     * @type {InlineResponse2003Collateral}
     * @memberof JpyxCdpCDP
     */
    principal?: InlineResponse2003Collateral;
    /**
     * 
     * @type {InlineResponse2003Collateral}
     * @memberof JpyxCdpCDP
     */
    accumulated_fees?: InlineResponse2003Collateral;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCDP
     */
    fees_updated?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCDP
     */
    interest_factor?: string;
}
/**
 * 
 * @export
 * @interface JpyxCdpCollateralParam
 */
export interface JpyxCdpCollateralParam {
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCollateralParam
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCollateralParam
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCollateralParam
     */
    liquidation_ratio?: string;
    /**
     * 
     * @type {InlineResponse2003Collateral}
     * @memberof JpyxCdpCollateralParam
     */
    debt_limit?: InlineResponse2003Collateral;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCollateralParam
     */
    stability_fee?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCollateralParam
     */
    auction_size?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCollateralParam
     */
    liquidation_penalty?: string;
    /**
     * 
     * @type {number}
     * @memberof JpyxCdpCollateralParam
     */
    prefix?: number;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCollateralParam
     */
    spot_market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCollateralParam
     */
    liquidation_market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCollateralParam
     */
    keeper_reward_percentage?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCollateralParam
     */
    check_collateralization_index_count?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpCollateralParam
     */
    conversion_factor?: string;
}
/**
 * 
 * @export
 * @interface JpyxCdpDebtParam
 */
export interface JpyxCdpDebtParam {
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpDebtParam
     */
    denom?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpDebtParam
     */
    reference_asset?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpDebtParam
     */
    conversion_factor?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpDebtParam
     */
    debt_floor?: string;
}
/**
 * 
 * @export
 * @interface JpyxCdpParams
 */
export interface JpyxCdpParams {
    /**
     * 
     * @type {Array<InlineResponse2005ParamsCollateralParams>}
     * @memberof JpyxCdpParams
     */
    collateral_params?: Array<InlineResponse2005ParamsCollateralParams>;
    /**
     * 
     * @type {InlineResponse2005ParamsDebtParam}
     * @memberof JpyxCdpParams
     */
    debt_param?: InlineResponse2005ParamsDebtParam;
    /**
     * 
     * @type {InlineResponse2003Collateral}
     * @memberof JpyxCdpParams
     */
    global_debt_limit?: InlineResponse2003Collateral;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpParams
     */
    surplus_auction_threshold?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpParams
     */
    surplus_auction_lot?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpParams
     */
    debt_auction_threshold?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxCdpParams
     */
    debt_auction_lot?: string;
    /**
     * 
     * @type {boolean}
     * @memberof JpyxCdpParams
     */
    circuit_breaker?: boolean;
}
/**
 * 
 * @export
 * @interface JpyxCdpQueryAllCdpResponse
 */
export interface JpyxCdpQueryAllCdpResponse {
    /**
     * 
     * @type {Array<InlineResponse2003Cdp>}
     * @memberof JpyxCdpQueryAllCdpResponse
     */
    Cdp?: Array<InlineResponse2003Cdp>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof JpyxCdpQueryAllCdpResponse
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface JpyxCdpQueryGetCdpResponse
 */
export interface JpyxCdpQueryGetCdpResponse {
    /**
     * 
     * @type {InlineResponse2003Cdp}
     * @memberof JpyxCdpQueryGetCdpResponse
     */
    Cdp?: InlineResponse2003Cdp;
}
/**
 * 
 * @export
 * @interface JpyxCdpQueryParamsResponse
 */
export interface JpyxCdpQueryParamsResponse {
    /**
     * 
     * @type {InlineResponse2005Params}
     * @memberof JpyxCdpQueryParamsResponse
     */
    params?: InlineResponse2005Params;
}
/**
 * 
 * @export
 * @interface JpyxIncentiveMultiplier
 */
export interface JpyxIncentiveMultiplier {
    /**
     * 
     * @type {string}
     * @memberof JpyxIncentiveMultiplier
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxIncentiveMultiplier
     */
    months_lockup?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxIncentiveMultiplier
     */
    factor?: string;
}
/**
 * 
 * @export
 * @interface JpyxIncentiveParams
 */
export interface JpyxIncentiveParams {
    /**
     * 
     * @type {Array<InlineResponse2006ParamsJpyxMintingRewardPeriods>}
     * @memberof JpyxIncentiveParams
     */
    jpyx_minting_reward_periods?: Array<InlineResponse2006ParamsJpyxMintingRewardPeriods>;
    /**
     * 
     * @type {Array<InlineResponse2006ParamsClaimMultipliers>}
     * @memberof JpyxIncentiveParams
     */
    claim_multipliers?: Array<InlineResponse2006ParamsClaimMultipliers>;
    /**
     * 
     * @type {string}
     * @memberof JpyxIncentiveParams
     */
    claim_end?: string;
}
/**
 * 
 * @export
 * @interface JpyxIncentiveQueryParamsResponse
 */
export interface JpyxIncentiveQueryParamsResponse {
    /**
     * 
     * @type {InlineResponse2006Params}
     * @memberof JpyxIncentiveQueryParamsResponse
     */
    params?: InlineResponse2006Params;
}
/**
 * 
 * @export
 * @interface JpyxIncentiveRewardPeriod
 */
export interface JpyxIncentiveRewardPeriod {
    /**
     * 
     * @type {boolean}
     * @memberof JpyxIncentiveRewardPeriod
     */
    active?: boolean;
    /**
     * 
     * @type {string}
     * @memberof JpyxIncentiveRewardPeriod
     */
    collateral_type?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxIncentiveRewardPeriod
     */
    start?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxIncentiveRewardPeriod
     */
    end?: string;
    /**
     * 
     * @type {InlineResponse2003Collateral}
     * @memberof JpyxIncentiveRewardPeriod
     */
    rewards_per_second?: InlineResponse2003Collateral;
}
/**
 * 
 * @export
 * @interface JpyxJsmndistParams
 */
export interface JpyxJsmndistParams {
    /**
     * 
     * @type {boolean}
     * @memberof JpyxJsmndistParams
     */
    active?: boolean;
    /**
     * 
     * @type {Array<InlineResponse2008ParamsPeriods>}
     * @memberof JpyxJsmndistParams
     */
    periods?: Array<InlineResponse2008ParamsPeriods>;
}
/**
 * 
 * @export
 * @interface JpyxJsmndistPeriod
 */
export interface JpyxJsmndistPeriod {
    /**
     * 
     * @type {string}
     * @memberof JpyxJsmndistPeriod
     */
    start?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxJsmndistPeriod
     */
    end?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxJsmndistPeriod
     */
    inflation?: string;
}
/**
 * 
 * @export
 * @interface JpyxJsmndistQueryGetBalancesResponse
 */
export interface JpyxJsmndistQueryGetBalancesResponse {
    /**
     * 
     * @type {Array<InlineResponse2003Collateral>}
     * @memberof JpyxJsmndistQueryGetBalancesResponse
     */
    balances?: Array<InlineResponse2003Collateral>;
}
/**
 * 
 * @export
 * @interface JpyxJsmndistQueryParamsResponse
 */
export interface JpyxJsmndistQueryParamsResponse {
    /**
     * 
     * @type {InlineResponse2008Params}
     * @memberof JpyxJsmndistQueryParamsResponse
     */
    params?: InlineResponse2008Params;
}
/**
 * 
 * @export
 * @interface JpyxPricefeedCurrentPrice
 */
export interface JpyxPricefeedCurrentPrice {
    /**
     * 
     * @type {string}
     * @memberof JpyxPricefeedCurrentPrice
     */
    market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxPricefeedCurrentPrice
     */
    price?: string;
}
/**
 * 
 * @export
 * @interface JpyxPricefeedMarket
 */
export interface JpyxPricefeedMarket {
    /**
     * 
     * @type {string}
     * @memberof JpyxPricefeedMarket
     */
    market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxPricefeedMarket
     */
    base_asset?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxPricefeedMarket
     */
    quote_asset?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof JpyxPricefeedMarket
     */
    oracles?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof JpyxPricefeedMarket
     */
    active?: boolean;
}
/**
 * 
 * @export
 * @interface JpyxPricefeedParams
 */
export interface JpyxPricefeedParams {
    /**
     * 
     * @type {Array<InlineResponse2009Markets>}
     * @memberof JpyxPricefeedParams
     */
    markets?: Array<InlineResponse2009Markets>;
}
/**
 * 
 * @export
 * @interface JpyxPricefeedPostedPrice
 */
export interface JpyxPricefeedPostedPrice {
    /**
     * 
     * @type {string}
     * @memberof JpyxPricefeedPostedPrice
     */
    market_id?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxPricefeedPostedPrice
     */
    oracle_address?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxPricefeedPostedPrice
     */
    price?: string;
    /**
     * 
     * @type {string}
     * @memberof JpyxPricefeedPostedPrice
     */
    expiry?: string;
}
/**
 * 
 * @export
 * @interface JpyxPricefeedQueryAllMarketResponse
 */
export interface JpyxPricefeedQueryAllMarketResponse {
    /**
     * 
     * @type {Array<InlineResponse2009Markets>}
     * @memberof JpyxPricefeedQueryAllMarketResponse
     */
    markets?: Array<InlineResponse2009Markets>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof JpyxPricefeedQueryAllMarketResponse
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface JpyxPricefeedQueryAllOracleResponse
 */
export interface JpyxPricefeedQueryAllOracleResponse {
    /**
     * 
     * @type {Array<string>}
     * @memberof JpyxPricefeedQueryAllOracleResponse
     */
    oracles?: Array<string>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof JpyxPricefeedQueryAllOracleResponse
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface JpyxPricefeedQueryAllPriceResponse
 */
export interface JpyxPricefeedQueryAllPriceResponse {
    /**
     * 
     * @type {Array<InlineResponse20011Price>}
     * @memberof JpyxPricefeedQueryAllPriceResponse
     */
    prices?: Array<InlineResponse20011Price>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof JpyxPricefeedQueryAllPriceResponse
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface JpyxPricefeedQueryAllRawPriceResponse
 */
export interface JpyxPricefeedQueryAllRawPriceResponse {
    /**
     * 
     * @type {Array<InlineResponse20012Prices>}
     * @memberof JpyxPricefeedQueryAllRawPriceResponse
     */
    prices?: Array<InlineResponse20012Prices>;
    /**
     * 
     * @type {InlineResponse200Pagination}
     * @memberof JpyxPricefeedQueryAllRawPriceResponse
     */
    pagination?: InlineResponse200Pagination;
}
/**
 * 
 * @export
 * @interface JpyxPricefeedQueryGetPriceResponse
 */
export interface JpyxPricefeedQueryGetPriceResponse {
    /**
     * 
     * @type {InlineResponse20011Price}
     * @memberof JpyxPricefeedQueryGetPriceResponse
     */
    price?: InlineResponse20011Price;
}
/**
 * 
 * @export
 * @interface JpyxPricefeedQueryParamsResponse
 */
export interface JpyxPricefeedQueryParamsResponse {
    /**
     * 
     * @type {InlineResponse20013Params}
     * @memberof JpyxPricefeedQueryParamsResponse
     */
    params?: InlineResponse20013Params;
}

/**
 * QueryApi - axios parameter creator
 * @export
 */
export const QueryApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auction: async (id: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling auction.');
            }
            const localVarPath = `/jpyx/auction/auctions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auctionAll: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/jpyx/auction/auctions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auctionParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/jpyx/auction/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balances: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/jpyx/jsmndist/balances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} id 
         * @param {string} [collateralType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cdp: async (id: string, collateralType?: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cdp.');
            }
            const localVarPath = `/jpyx/cdp/cdps/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (collateralType !== undefined) {
                localVarQueryParameter['collateral_type'] = collateralType;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cdpAll: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/jpyx/cdp/cdps`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cdpParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/jpyx/cdp/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incentiveParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/jpyx/incentive/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jsmndistParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/jpyx/jsmndist/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketAll: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/jpyx/pricefeed/markets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oracleAll: async (marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketId' is not null or undefined
            if (marketId === null || marketId === undefined) {
                throw new RequiredError('marketId','Required parameter marketId was null or undefined when calling oracleAll.');
            }
            const localVarPath = `/jpyx/pricefeed/markets/{market_id}/oracles`
                .replace(`{${"market_id"}}`, encodeURIComponent(String(marketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        price: async (marketId: string, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketId' is not null or undefined
            if (marketId === null || marketId === undefined) {
                throw new RequiredError('marketId','Required parameter marketId was null or undefined when calling price.');
            }
            const localVarPath = `/jpyx/pricefeed/markets/{market_id}/price`
                .replace(`{${"market_id"}}`, encodeURIComponent(String(marketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceAll: async (paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/jpyx/pricefeed/prices`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricefeedParams: async (options: any = {}): Promise<RequestArgs> => {
            const localVarPath = `/jpyx/pricefeed/params`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawPriceAll: async (marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options: any = {}): Promise<RequestArgs> => {
            // verify required parameter 'marketId' is not null or undefined
            if (marketId === null || marketId === undefined) {
                throw new RequiredError('marketId','Required parameter marketId was null or undefined when calling rawPriceAll.');
            }
            const localVarPath = `/jpyx/pricefeed/markets/{market_id}/raw_prices`
                .replace(`{${"market_id"}}`, encodeURIComponent(String(marketId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, 'https://example.com');
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (paginationKey !== undefined) {
                localVarQueryParameter['pagination.key'] = paginationKey;
            }

            if (paginationOffset !== undefined) {
                localVarQueryParameter['pagination.offset'] = paginationOffset;
            }

            if (paginationLimit !== undefined) {
                localVarQueryParameter['pagination.limit'] = paginationLimit;
            }

            if (paginationCountTotal !== undefined) {
                localVarQueryParameter['pagination.count_total'] = paginationCountTotal;
            }


    
            const queryParameters = new URLSearchParams(localVarUrlObj.search);
            for (const key in localVarQueryParameter) {
                queryParameters.set(key, localVarQueryParameter[key]);
            }
            for (const key in options.query) {
                queryParameters.set(key, options.query[key]);
            }
            localVarUrlObj.search = (new URLSearchParams(queryParameters)).toString();
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QueryApi - functional programming interface
 * @export
 */
export const QueryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auction(id: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).auction(id, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auctionAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).auctionAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async auctionParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).auctionParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async balances(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2007>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).balances(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} id 
         * @param {string} [collateralType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cdp(id: string, collateralType?: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).cdp(id, collateralType, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cdpAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).cdpAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cdpParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).cdpParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async incentiveParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2006>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).incentiveParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async jsmndistParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2008>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).jsmndistParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async marketAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2009>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).marketAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oracleAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20010>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).oracleAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} marketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async price(marketId: string, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20011>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).price(marketId, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async priceAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20014>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).priceAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pricefeedParams(options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20013>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).pricefeedParams(options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rawPriceAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse20012>> {
            const localVarAxiosArgs = await QueryApiAxiosParamCreator(configuration).rawPriceAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options);
            return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
                const axiosRequestArgs = {...localVarAxiosArgs.options, url: (configuration?.basePath || basePath) + localVarAxiosArgs.url};
                return axios.request(axiosRequestArgs);
            };
        },
    }
};

/**
 * QueryApi - factory interface
 * @export
 */
export const QueryApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    return {
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auction(id: string, options?: any): AxiosPromise<InlineResponse2001> {
            return QueryApiFp(configuration).auction(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auctionAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse200> {
            return QueryApiFp(configuration).auctionAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        auctionParams(options?: any): AxiosPromise<InlineResponse2002> {
            return QueryApiFp(configuration).auctionParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        balances(options?: any): AxiosPromise<InlineResponse2007> {
            return QueryApiFp(configuration).balances(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} id 
         * @param {string} [collateralType] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cdp(id: string, collateralType?: string, options?: any): AxiosPromise<InlineResponse2004> {
            return QueryApiFp(configuration).cdp(id, collateralType, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cdpAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse2003> {
            return QueryApiFp(configuration).cdpAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cdpParams(options?: any): AxiosPromise<InlineResponse2005> {
            return QueryApiFp(configuration).cdpParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        incentiveParams(options?: any): AxiosPromise<InlineResponse2006> {
            return QueryApiFp(configuration).incentiveParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        jsmndistParams(options?: any): AxiosPromise<InlineResponse2008> {
            return QueryApiFp(configuration).jsmndistParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary this line is used by starport scaffolding # 2
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        marketAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse2009> {
            return QueryApiFp(configuration).marketAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oracleAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20010> {
            return QueryApiFp(configuration).oracleAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        price(marketId: string, options?: any): AxiosPromise<InlineResponse20011> {
            return QueryApiFp(configuration).price(marketId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        priceAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20014> {
            return QueryApiFp(configuration).priceAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pricefeedParams(options?: any): AxiosPromise<InlineResponse20013> {
            return QueryApiFp(configuration).pricefeedParams(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} marketId 
         * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
         * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
         * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
         * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rawPriceAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any): AxiosPromise<InlineResponse20012> {
            return QueryApiFp(configuration).rawPriceAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QueryApi - object-oriented interface
 * @export
 * @class QueryApi
 * @extends {BaseAPI}
 */
export class QueryApi extends BaseAPI {
    /**
     * 
     * @summary this line is used by starport scaffolding # 2
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public auction(id: string, options?: any) {
        return QueryApiFp(this.configuration).auction(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public auctionAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).auctionAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public auctionParams(options?: any) {
        return QueryApiFp(this.configuration).auctionParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary this line is used by starport scaffolding # 2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public balances(options?: any) {
        return QueryApiFp(this.configuration).balances(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary this line is used by starport scaffolding # 2
     * @param {string} id 
     * @param {string} [collateralType] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public cdp(id: string, collateralType?: string, options?: any) {
        return QueryApiFp(this.configuration).cdp(id, collateralType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public cdpAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).cdpAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public cdpParams(options?: any) {
        return QueryApiFp(this.configuration).cdpParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public incentiveParams(options?: any) {
        return QueryApiFp(this.configuration).incentiveParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public jsmndistParams(options?: any) {
        return QueryApiFp(this.configuration).jsmndistParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary this line is used by starport scaffolding # 2
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public marketAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).marketAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketId 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public oracleAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).oracleAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public price(marketId: string, options?: any) {
        return QueryApiFp(this.configuration).price(marketId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public priceAll(paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).priceAll(paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public pricefeedParams(options?: any) {
        return QueryApiFp(this.configuration).pricefeedParams(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} marketId 
     * @param {string} [paginationKey] key is a value returned in PageResponse.next_key to begin querying the next page most efficiently. Only one of offset or key should be set.
     * @param {string} [paginationOffset] offset is a numeric offset that can be used when key is unavailable. It is less efficient than using key. Only one of offset or key should be set.
     * @param {string} [paginationLimit] limit is the total number of results to be returned in the result page. If left empty it will default to a value to be set by each app.
     * @param {boolean} [paginationCountTotal] count_total is set to true  to indicate that the result set should include a count of the total number of items available for pagination in UIs. count_total is only respected when offset is used. It is ignored when key is set.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QueryApi
     */
    public rawPriceAll(marketId: string, paginationKey?: string, paginationOffset?: string, paginationLimit?: string, paginationCountTotal?: boolean, options?: any) {
        return QueryApiFp(this.configuration).rawPriceAll(marketId, paginationKey, paginationOffset, paginationLimit, paginationCountTotal, options).then((request) => request(this.axios, this.basePath));
    }
}


